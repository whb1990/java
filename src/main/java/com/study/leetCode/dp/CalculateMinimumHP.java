package main.java.com.study.leetCode.dp;

/**
 * @author: whb
 * @date: 2020/7/13 10:10
 * @description: LeetCode-174-地下城游戏
 * 难度：困难
 * 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
 *
 * 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
 *
 * 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
 *
 * 为了尽快到达公主，骑士决定每次只向右或向下移动一步。
 *
 * 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
 *
 * 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
 *
 * -2 (K)	-3	3
 * -5	-10	1
 * 10	30	-5 (P)
 *
 * 说明:
 *
 * 骑士的健康点数没有上限。
 *
 * 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。
 */
public class CalculateMinimumHP {
    /**
     * 动态规划
     * 从终点往起点走，只要保证不死就行。与此同时，加血的过程变成掉血，掉血的过程变成加血，如果当前血量如果<=0，就将血量置1，这样可以最大限度保证最小血量还不死。
     * <p>
     * 当前血量有两种走法，一种是从左边过来，一种是从下面上来。如果当前格是小怪兽，那么骑士会掉血，对于从终点来的骑士，就需要+|血量|（加上血量的绝对值），以保证他不会死，
     * 如果这一格有魔法球，骑士可以加血，那么到这一格所需要的血量就需要-当前元素值，如果减完发现骑士血量为负，就表示死着到这儿都行，但是血量必须>=1，所以为负的时候直接置1。
     * <p>
     * 先检查两个边边（最下和最右）的血量，再检查中间的矩阵，原因是边边上只有一种走法。
     *
     * @param dungeon
     * @return
     */
    public static int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[][] dp = new int[row][col];
        for (int i = row - 1; i >= 0; i--) {
            for (int j = col - 1; j >= 0; j--) {
                if (i == row - 1 && j == col - 1) {
                    //终点
                    dp[i][j] = Math.max(1, 1 - dungeon[row - 1][col - 1]);
                } else if (i == row - 1) {
                    //最后一行
                    dp[i][j] = Math.max(1, dp[i][j + 1] - dungeon[i][j]);
                } else if (j == col - 1) {
                    //最后一列
                    dp[i][j] = Math.max(1, dp[i + 1][j] - dungeon[i][j]);
                } else {
                    //其他
                    dp[i][j] = Math.max(1, Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);
                }
            }
        }
        return dp[0][0];
    }

    public static void main(String[] args) {
        System.out.println(calculateMinimumHP(new int[][]{{-2, -3, 3}, {-5, -10, 1}, {10, 30, -5}}));
    }
}
