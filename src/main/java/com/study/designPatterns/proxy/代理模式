**代理模式：**
给某一个对象（目标对象）提供一个代理，并由代理对象控制原对象（目标对象）的引用进行操作，这种模式一般称之为代理模式。

代理模式是结构型模式中的一种。既然要弄清楚代理模式，那么必须要先了解什么是结构性设计模式。
结构性设计模式存在的目的主要是：在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点。因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等等。
因此，结构性模式最主要涉及和关心的是如何组合类和对象来获得更大的结构。
**结构性模式采用继承机制来组合接口或实现（也称为：类结构性模式）**，或者通过组合一些对象从而实现新的功能（也称为对象结构性模式）。综上，结构性模式它不是对接口和实现进行组合，而是描述了如何对一些对象进行组合。

**解决的问题：**

代理模式主要针对的是直接访问对象时可能会带来的问题，比如有些对象由于某些原因（例如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，因此我们可以在访问此对象时，加上一个对此对象的访问中间层。其优点就在于拓展性极高（黄牛不仅可以卖火车票，它也可以推荐你买飞机票、买长途大巴票）、内部功能隐蔽；缺点就是因为增加了中间件，这样多余的一层可能会造成请求的处理速度相对变慢。

**有哪几种代理模式？**

如果按照代理创建的时期来进行分类的话， 可以分为两种：**静态代理**、**动态代理**。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。

**静态代理：**

优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。     

**JDK动态代理：**

在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。

虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。

**CGLIB动态代理：**

JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。

**示例说明：**

demoOne是代购mac；
demoTwo是代购火车票；
staticProxy是静态代理；
jdkProxy是JDK动态代理；
cglibProxy是CGLIB动态代理；






















